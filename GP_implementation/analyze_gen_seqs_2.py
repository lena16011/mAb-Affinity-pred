'''
Script to calculating some statistics from the VDJ sequences that were generated by randomly sampling
combinations of mutations and predicted.
'''


import pandas as pd
import stringdist
import numpy as np
from utils import NW_functions as NW



# prepare the sequence list for the network plots; create 3-tuples; just from another script
# re-used to calculate some statistics
def ebunch_LD(seqs_lst, dist_matrix, LD = None):
    '''
        Function to calculate the distance matrix (Levenshtein distance) and then store the
        sequence pairs as 3-tuples with the connected sequences and their corresponding
        Levenshtein distance;

        - seq_lst is a list of the input sequences for pairwise distance calculation
        - LD is the Levenshtein distance of which want the function to return the ebunches
        :return ebunch : is a list of 3-tuples;
    '''

    # initialize numpy 2d array for the matrix
    D = pd.DataFrame(dist_matrix)


    # now we can store the 3-tuples with the distances as weights (ebunch for the network graph)
    data_tup = []
    for i in range(len(seqs_lst)):
        for j in range(i + 1, len(seqs_lst)):
            if LD !=None:
                if D.iloc[j, i] == LD:
                    val = (i, j, D.iloc[j, i])
                    data_tup.append(val)
            elif LD == None:
                val = (i, j, D.iloc[j, i])
                data_tup.append(val)
    return data_tup


def ebunch_norm(seqs_lst, dist_matrix, LD = None):
    '''
        Function to calculate the distance matrix (Levenshtein distance) and then store the
        sequence pairs as 3-tuples with the connected sequences and their corresponding
        Levenshtein distance;

        - seq_lst is a list of the input sequences for pairwise distance calculation
        - LD is the Levenshtein distance of which want the function to return the ebunches
        :return ebunch : is a list of 3-tuples;
    '''

    # initialize numpy 2d array for the matrix
    D = pd.DataFrame(dist_matrix)

    # now we can store the 3-tuples with the distances as weights (ebunch for the network graph)
    data_tup = []
    for i in range(len(seqs_lst)):
        for j in range(i + 1, len(seqs_lst)):
            if LD !=None:
                if D.iloc[j, i] == LD:
                    val = (i, j, D.iloc[j, i])
                    data_tup.append(val)
            elif LD == None:
                val = (i, j, D.iloc[j, i])
                data_tup.append(val)
    return data_tup




## Set input directories
abs_path = 'D:/Dokumente/Masterarbeit/Lena/GP_implementation'

in_dir = ['/data/gen_seqs_muvar/10_8/pos/',
          '/data/gen_seqs_muvar/10_8/neg/',
          '/data/gen_seqs_muvar/midr/']

files = ['all_new_seq_gen_pos.csv', 'all_new_seq_gen_neg.csv', 'all_new_seq_gen_mid.csv']

# set True, if distance matrices should be stored
save = False

# loop through files
for i in range(len(files)):

    in_file = in_dir[i] + files[i]


    ## load data from generated/predicted sequences

    data = pd.read_csv(in_file, index_col=0)

    ### Calculate distance matrices

    # get the first sequences as list (with lowest KD)
    seq_lst = list(data.Sequences)


    # calculate norm distance matrix
    dist_norm = NW.calculate_norm_dist_matrix(seq_lst, verbose=True)

    # save normal. distance matrix and save
    if save == True:
        np.savetxt(in_dir[i]+'norm_dist_matrix_1000.csv', dist_norm, delimiter = ',')

    # calculate LD distance matrix and save
    dist_LD = NW.calculate_LD_dist_matrix(seq_lst, verbose=True)
    if save == True:
        np.savetxt(in_dir[i]+'LDdist_matrix_.csv', dist_norm, delimiter = ',')


    # create ebunches to calculate statistics
    eb = ebunch_LD(seq_lst, dist_LD)
    mean_LD = np.mean([eb[x][2] for x in range(len(eb))])
    max_LD = max([eb[x][2] for x in range(len(eb))])

    # similarity
    eb_norm = ebunch_norm(seq_lst, dist_norm)
    mean_sim = 1 - np.mean([eb_norm[x][2] for x in range(len(eb_norm))])
    min_sim = min([1-eb_norm[x][2] for x in range(len(eb_norm))])
    max_sim = max([1-eb_norm[x][2] for x in range(len(eb_norm))])


    # print the stats
    print("file: {}".format(files[index]))
    print("# selected VDJs",'\t',len(dist_LD))
    print("length of VDJs",'\t',np.unique([len(x) for x in seq_lst]))

    print("range of selected LDs",'\t',np.unique(dist_LD))
    print("mean LD",'\t',round(mean_LD, 1))
    print("max LD",'\t',max_LD)

    print("mean Similarity",'\t', str(round(mean_sim, 3)))
    print("min Similarity",'\t',str(round(min_sim, 3)))
    print("max Similarity",'\t',str(round(max_sim, 3)))










